# problem link - https://leetcode.com/problems/number-of-good-paths/description/
# code - 
class Solution {
public:
    vector<int> parent;
    vector<int> rank;

    int find(int x){
        if(x == parent[x]) return x;
        return parent[x] = find(parent[x]);
    }

    void unions(int x, int y){
        int x_p = find(x);
        int y_p = find(y);
        if(x_p == y_p) return;

        if(rank[x_p] > rank[y_p]){
            parent[y_p] = x_p;
        }
        else if(rank[x_p] < rank[y_p]){
            parent[x_p] = y_p;
        }
        else{
            parent[x_p] = y_p;
            rank[y_p]++;
        }
    }

    int numberOfGoodPaths(vector<int>& vals, vector<vector<int>>& edges) {
        int n = vals.size();
        parent.resize(n);
        rank.resize(n, 0);
        for(int i = 0; i < n; i++){
            parent[i] = i;
        }

        // Build adjacency
        vector<vector<int>> adj(n);
        for(auto &e : edges){
            adj[e[0]].push_back(e[1]);
            adj[e[1]].push_back(e[0]);
        }

        // Map values -> nodes
        map<int, vector<int>> val_to_nodes;
        for(int i = 0; i < n; i++){
            val_to_nodes[vals[i]].push_back(i);
        }

        vector<bool> active(n, false);
        int result = 0;

        // Process values in increasing order
        for(auto &entry : val_to_nodes){
            int val = entry.first;
            vector<int> nodes = entry.second;

            // Activate these nodes
            for(int u : nodes){
                active[u] = true;
                for(int v : adj[u]){
                    if(active[v] && vals[v] <= val){
                        unions(u, v);
                    }
                }
            }

            // Count nodes with same parent
            unordered_map<int,int> count;
            for(int u : nodes){
                int root = find(u);
                count[root]++;
            }

            // Each group contributes C(k,2) + k (self paths)
            for(auto &p : count){
                int k = p.second;
                result += (k * (k-1)) / 2; // pairs
            }
        }

        return result + n; // add single-node paths
    }
};
